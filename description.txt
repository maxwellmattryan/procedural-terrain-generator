I chose to design a procedural terrain generator as my system implementation even though it is more of a technical design system rather than a direct gameplay-related one. I love the open-world game genre, so I wanted to understand at least one way of implementing an inifinitely explorable space. I would also like to add that I followed a tutorial series in order to complete this project, while making slight alterations to the code as I saw fit. The series can be found here - https://www.youtube.com/playlist?list=PLFt_AvWsXl0eBW2EiBtl_sxmDtSgZBxB3

The first step in creating the terrain generator was first making a script to generate noise values between 0 and 1 across a two-dimensional noise map. It's important that the type of noise used is Perlin noise, because it uses a specific algorithm to blend pseudo-random noise values according to gradient vectors. With that, the terrain will look much more natural and changes happen gradually as they most often would in the real world.

The second step was to create a color map based off of these noise values. I first had to define what colors mapped to what intervals between values. For example, mountains will often have snow on the tops of them, so values from the noise map between 0.9 and 1.0 should correlate to a snow-color since that is the highest possible range for a value. Conversely, I set the lowest values to correspond with a few different water colors because it was the lowest type of region for the terrain.

The third step was to create a three-dimensional mesh from both the noise (aka height) and color maps. Triangles are calculated and added to the meshes according to the height values read in. The terrain chunks are generated each with an appropriate texture based off of the color mappings.

The fourth step was creating the actual endless terrain mechanism. The system generates terrain chunks according to the distance from the viewer to the nearest triangle in the terrain's mesh. One difficulty here is that the current terrain chunk for the viewer shuold have a higher level of detail than those farther away. Having more detail that the player cannot see simply creates unneeded work for our machines by having to generate so many superfluous vertices. Because of that, it was necessary to use distance thresholds to control each mesh's level of detail for the sake of performance. Also with multiple chunks of terrain, it was important that they connected together seamlessly. The underlying problem is that the normals of each mesh's border triangles needs to be informed about the adjacent mesh's border triangles so that the lighting matches. Lasly, threading was implemented at this step so that generating noise maps and terrain meshes would happen more efficiently. 

The fifth step was simply importing the standard first person controller just for the sake of being able to actually explore the world. I think I spent roughly 5 or so minutes just running around at first - it was too much fun ! 

The sixth and last step was applying a flat shader to the meshes. This wasn't entirely necessary, but adding this functionality required some other implementation changes. Before this change, each triangle was blending with the other's around it, which allowed for a lower vertex count (since they're shared). In order to apply flat shading, each of the three triangles' normals need to point in the same direction, but this required storing three vertices per triangle. Because Unity enforces a triangle limit on meshes, flat shading requires a considerably lower vertex count resulting in a smaller chunk size.

There were quite a few (both programming and not) techniques that I haven't used in Unity before that was used in the tutorial. These included threading, scriptable objects, structs, vector cross products, creating meshes and textures dynamically, and various editor attributes for creating more editable parameters. Overall I feel that I learned a great deal through following along and building this system.